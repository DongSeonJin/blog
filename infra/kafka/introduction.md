# Introduction

아파치 카프카는 '분산 커밋 로그' 혹은 '분산 스트리밍 플랫폼' 이라고 불리기도 한다.&#x20;



* 카프카는 메시지를 배치(batch) 단위로 저장한다.

메시지를 쓸 때마다 네트워크 신호가 오간다면 막대한 오버헤드가 발생하는데, 메시지를 배치 단위로 모아서 쓰면 이것을 줄일 수 있다. 예를들어, 메시지 100개는 네트워크 요청이 100번 이루어지지만 배치 전송은 1번의 요청으로 처리된다.

&#x20;하지만, 배치 크기가 커질 수록 시간당 처리량은 늘어나지만, 지연시간은 늘어나는 트레이드오프를 발생시킨다.



### 카프카의 프로듀서와 컨슈머는 데이터를 생산하고 소비하는 핵심 주체이다.

![](../../.gitbook/assets/Gemini_Generated_Image_vixgp2vixgp2vixg.jpg).



* 프로듀서 (Producer) 🧑‍💻➡️: 메시지(데이터)를 생성하여 카프카의 특정 주제(Topic)로 보내는 역할을 한다. 데이터를 만드는 생산자이다.
* 컨슈머 (Consumer) ⬅️🧑‍🔧: 토픽을 구독(subscribe)하고, 저장된 메시지를 가져와서 원하는 작업을 처리한다. 데이터를 사용하는 소비자이다.

이 구조 덕분에 프로듀서와 컨슈머는 서로를 직접 알 필요 없이, 카프카를 통해 데이터를 안정적으로 주고받을 수 있다.





## 토픽과 파티션

카프카에 저장되는 메시지는 토픽 단위로 분류된다. 토픽은 다시 여러 개의 파티션으로 나뉘어진다. 파티션은 카프카가 데이터 중복과 확장성을 제공하는 방법이기도 하다. 또한, 파티션은 복제될 수 있다. 서로 다른 서버들이 동일한 파티션의 복제본을 저장하고 있기 때문에 서버 중 하나에 장애가 발생한다고 해서 읽거나 쓸 수 없는 상황이 벌어지지는 않는다.





## 파티션의 존재 이유

* 하나의 토픽으로도 메시지 처리가 가능하지만, 왜 토픽 내부에는 여러 파티션으로 나뉘어져 있을까?&#x20;

하나의 토픽에 대한 데이터 처리를 병렬화하여 성능을 수평적으로 확장하기 위함이다.

토픽에 저장된 데이터를 읽어오기 위해 협업하는 하나 이상의 컨슈머로 이루어진 것을 '컨슈머 그룹'이라고 한다. 컨슈머 그룹에 속한 여러 컨슈머들이 토픽 내부의 파티션으로 접근이 가능하다. 즉, 파티션을 나누므로써 다수의 클라이언트가 데이터를 읽을 수 있다는 것이다.



* 왜 파티션 하나에 하나의 컨슈머만 접근이 가능한가?

&#x20;컨슈머는 메시지의 오프셋을 기록함으로써 어느 메시지까지 읽었는지를 유지한다. 즉, 컨슈머는 읽기 작업을 정지했다가 다시 시작하더라도 마지막으로 읽었던 메시지의 바로 다음 메시지부터 읽을 수 있다.

&#x20;그런데, 파티션 하나에 여러 컨슈머가 접근이 가능하다면? 오프셋 데이터 중복으로 데이터 처리의 순서 보장과 정합성이 깨지게 된다.







## 파티션 리더

&#x20;파티션은 클러스터 안의 브로커 중 하나가 담당하며, 그 브로커를 파티션 리더 라고 부른다. 복제된 파티션이 여러 브로커에 할당될 수도 있는데 이것들을 파티션의 팔로워 라고 부른다.

&#x20;햇갈렸던 것은 '파티션 리더'는 하나의 브로커로 이루어져 있고, 그 파티션들을 팔로워들이 복제하여 부하를 분산하는 개념이라고 이해하였다.

&#x20;파티션 리더는 여러 브로커에 할당할 수 있으며, 리더와 팔로워가 할당되는 기준은 '브로커'가 아닌 '파티션' 단위로 이해하면 될 것 같다. (ElasticSearch도 동일한 아키택처를 가지고있다고 한다.)





### 브로커와 클러스터

하나의 카프카 서버를 브로커라고 부른다. 이는 메시지를 수신하여 디스크에 안전하게 저장하는 핵심적인 역할을 담당한다. 프로듀서가 전송한 데이터를 토픽 단위로 관리하며, 컨슈머의 요청이 있을 때 해당 데이터를 전달하는 책임을 진다.

* 클러스터

클러스터는 여러 대의 브로커를 하나로 묶어 구성한 단일 시스템을 말한다. 이중 하나의 브로커가 컨트롤러의 역할을 하게 된다. (작동중인 브로커 중 하나가 자동으로 선정된다)  컨트롤러는 파티션을 브로커에 할당하거나 브로커를 모니터링 하는 등의 관리 기능을 담당한다.

하나의 브로커에 장애가 발생하더라도, 클러스터 내의 다른 브로커가 작업을 이어받는다. 이를 통해 데이터의 유실 없이 안정적인 서비스 운영을 보장한다.

* 클러스터 내 브로커의 갯수는 홀수단위로 (3, 5)

쿼럼 방식을 사용, 과반수 이상의 투표자로 파티션 리더를 선정하기 때문에 홀수단위로 저장을 해야한다.

(ElasticSearch 도 같은 클러스터 개념을 가지고 있다.)







## 느슨한 결합 (Loose Coupling)

카프카의 느슨한 결합은 데이터를 만드는 주체(프로듀서)와 사용하는 주체(컨슈머)가 서로에 대한 의존성을 최소화하는 아키텍처 원칙을 의미한다. 카프카는 둘 사이에 중간다리(버퍼) 역할을 함으로써 이 결합을 느슨하게 만든다.

느슨한 결합 덕분에 시스템 전체가 더 유연하고, 확장 가능하며, 안정적으로 운영될 수 있다.



## 디스크 기반 보존

레빗엠큐 ( 메모리 큐, 디스크 기반으로도 가능 )

레디스 ( 메모리 큐 )

카프카 (디스크 보존 )

