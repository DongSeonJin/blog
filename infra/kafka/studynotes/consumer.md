---
description: 카프카 컨슈머
---

# Consumer



카프카에서 데이터를 읽는 애플리케이션은 토픽을 구독하고 구독한 토픽들로부터 메시지를 받기 위해 KafkaConsumer를 사용한다. 카프카에서 데이터를 읽는 것은 다른 메시지 전달 시스템에서 데이터를 읽는 것과는 조금 다르다.





## 컨슈머와 컨슈머 그룹

> 단일 컨슈머가 토픽을 구독하고 메시지를 받기 시작한 뒤 받은 메시지를 받아 검사하고 결과를 쓴다고 생각해보자. 어떤 문제가 있을까? 만약 프로듀서가 애플리케이션이 검사할 수 있는 속도보다 더 빠른 속도로 토픽에 메시지를 쓰기 시작한다면, 새로 추가되는 메시지의 속도를 따라잡지 못하고 결국에는 메시지 처리가 뒤로 밀릴 것이다.
>
> 하나의 토픽이 다수의 파티션으로 나뉘어 있을 경우, 컨슈머 그룹 내의 컨슈머들은 각기 다른 파티션을 할당받아 병렬로 메시지를 처리한다. 이를 통해 소비 처리량을 수평적으로 확장할 수 있다.





## Springboot 컨슈머 설정

```
# 3. 컨슈머(Consumer) 설정
consumer:
  # 컨슈머 그룹 ID (필수)
  group-id: my-group
  # 브로커로부터 받은 바이트를 객체로 변환하는 역직렬화(Deserializer) 클래스 지정
  key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
  value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
  # (옵션) 처음 연결 시 읽을 오프셋 위치 (earliest: 가장 오래된 메시지부터)
  auto-offset-reset: earliest
```







## 파티션 할당 전략

_리밸런스에는 컨슈머 그룹이 사용하는 파티션 할당 전략에 따라 2가지가 있다._

#### 1. 조급한 리밸런스(eager rebalance)

> 컨슈머 그룹에 변경 사항(새 컨슈머 추가, 기존 컨슈머 이탈 등)이 발생했을 때, 그룹 내 모든 컨슈머가 자신이 담당하던 모든 파티션을 즉시 포기하고, 메시지 처리를 완전히 중단하는 'Stop-the-World' 방식으로 동작한다.
>
> 이 방식의 가장 큰 단점은 리밸런스가 발생하는 동안 그룹 전체의 데이터 처리가 멈추기 때문에, 일시적인 서비스 중단이 발생한다는 점이다.

#### 2. 협력적 리밸런스(cooperative rebalance)

> 컨슈머 그룹에 변경 사항이 발생해도, 모든 컨슈머가 작업을 멈추는 대신 재할당이 필요한 파티션만 일부 컨슈머가 반납하고, 컨슈머 그룹 리더가 반납된 파티션들을 새로 할당한다. 나머지 컨슈머들은 중단 없이 메시지 처리를 계속하는 방식이다.
>
> 이 방식의 가장 큰 장점은 리밸런스 중에도 컨슈머 그룹 전체가 멈추지 않아, 서비스 중단 시간을 최소화하고 안정성을 크게 향상시킨다는 점이다.















